# :after清除浮动的原理和方法

1.为何要清除浮动
- 情况: 当容器内的子元素是浮动元素时,子元素会浮动到父元素外部.
- 原因: 浮动定位不属于正常的文档流,是独立定位的.只含有浮动子元素的父元素,在渲染视图时不会包含子元素的位置,所以子元素会显示在父元素外

2.解决办法
- 1.添加一个空的浮动元素

    原理是父容器现在必须考虑非浮动子元素的位置，而后者肯定出现在浮动元素下方，所以显示出来，父容器就把所有子元素都包括进去了。这种方法比较简单，但是要在页面中增加冗余标签，违背了语义网的原则。

- 2.父元素浮动

    这种方法不用修改HTML代码，但是缺点在于父容器变成浮动以后，会影响到后面元素的定位，而且有时候，父容器是定位死的，无法变成浮动。

- 3.浮动元素的自动clearing

    让父容器变得可以自动"清理"（clearing）子元素的浮动，从而能够识别出浮动子元素的位置，不会出现显示上的差错。
    要做到这点，只要为父容器加上一条"overflow: hidden"的CSS语句就行了。关于为何父容器可以自动识别：由于加上overflow:hidden之后要计算超出的大小来隐藏，所以父容器会自动撑开自己把所有的子元素放进去，同时会计算浮动的子元素。
   缺点:IE 6不支持，另一个是一旦子元素的大小超过父容器的大小，就会出显示问题。
- 4.clearfix:after
```css
.clearfix:after {
content: "\0020";
display: block;
height: 0;
clear: both;
}
.clearfix {
zoom: 1;
}
```
- `:after`伪选择符，就可以在父容器的尾部创建一个子元素。
- `clearfix`是父容器的class名称，
- `content:"020";`是在父容器的结尾处放一个空白字符
- `height: 0;`是让这个这个空白字符不显示出来
- `display: block; clear: both;`是确保这个空白字符是非浮动的独立区块。
- 但是，:after选择符IE 6不支持
添加一条IE 6的独有命令`zoom:1;`作用是激活父元素的`hasLayout`属性，让父元素拥有自己的布局。IE 6会读取这条命令，其他浏览器则会直接忽略它。